# Persistent Data Structures and Managed References

* **Speaker: Rich Hickey**
* **Conference: [QCon]() - Oct 2009**
* **Video: [http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey](http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey)**

How many people program in a functional programming language? Okey, so halfway ??? converted and not in a functional programming language, a non-functional programming language? so still a lot of that. Ah, I think this will be useful to both audiences and in particular if you're not in a functional programming language, in fact if you're not in Erlang, which I think has a complete story for how they do state, all the other functional programming languages have you know 2 aspects, they have this functional part, and then, and then, you know, Haskell has this beautiful side where the type system keeps this part pure and then there's the other part which is kind of imperative, do this do that, and then they have a bunch of constructs to make,err , provide the facility for ??? state ,on that side ? Similarly there are a lot of hybrid functional programming languages, like Scala, F#, where I think there are questions to be asked about, okey here's the pure part, what's the story about the other part. So what I want to do today is to talk about functions and processes and to distinguish the two. In fact, the core concert in this talk is it to try to parse out what we mean by identity, state and values, try to separate those concepts and see how programming with values while a really important part of the functional of your program ends up being a critical part of the non functional part of you program, the part that actually has to manage state and behaviors if things are changing, and there are two components in that one is how you represent composite objects and values. Lot of people who are new to functional programming wonder about the efficiency and representation issues there and I'll talk about that and finally I'll talk about one approach to dealing with state and change in a  program, the one that Clojure uses, which is compatible with a little bit of philosophy which I'm gonna start with.

I'm not really gonna talk about Clojure very much, how many people were in the talk yesterday. Okey, how many people who weren't know something about Clojure. Okey. This is not really a Clojure specific talk, though there'll be some code later, it shouldn't be too threatening. Just gonna summarize quickly with this one slide. What Clojure is about is it's a dynamic programming language, it's dynamically typed, it's functional in particularly, it's functional in emphasizing immutability, not just in, you know, supporting higher order functions. All the data types in Clojure are immutable. It supports concurrency  in that it's a two part story, one is you have type support for immutability and pure functions, the other part is you have to have story for when multiple things happening at a time and you're gonna have some perceptible change, and Clojure does. In fact, I think it's an important part of a language that purports to be functional to have a story about the non-functional part. Clojure is not particularly object oriented, it may be clear after listening to this talk why not, because I think as currently implemented, all of the object-oriented technologies have big problems when they face concurrency and functional programming, as I said, from a conceptual standpoint nothing about this is Clojure specific.

So what do we mean by functions, I think that there's a really easy way saying oh function is something that you call and that's not what we're talking about here, we're talking about a very precise notion of function which is something that you call that takes values as arguments and produces values as returns. When it's given the same arguments, it always produces the same values, it doesn't depend on the outside world, it doesn't affect the rest of the world. So many methods in your classes are not functions by this definition, but in particular too, I want to highlight the fact that pure functions have no notion of time. Time is gonna be a critical notion through this talk.

So what is functional programming, there are a lot of answers to this questions and I think people who are really into type system will claim a stronger arguments for what constitues functional programming. But I'm gonna limit the definition here to, you know, programming that emphasizes program with functions, so you wanna try to write as much of your program as you can with pure functions. When you do that you get a ton of benefits, they've been talking about that in other talks, it's not really the focus of this talk other than to say, even without concurrency, your program will be easier to understand, easier to reason about, easier to test, more modular and so forth. That all falls out of programming with functions to the greatest an extent as possible. On the other hand, when you step back and look at your entire program, very few programs on the whole, are functions. You know, that takes a single input and think about it and produces a single output. Maybe some compiler or theorem provers work that way, but most real world programs that I worked on, and I think most real world programs in the real world don't work that way. In particular, well, even if you claim your program is completely functional, it's gonna produce, say, outputs, it's not, coz otherwise it's just gonna warm up the machine. But, even if it's mostly functional, there's still an observable effect of a purely functional program runnning, right. It's running on a computer, as soon as it's running on a computer it's not math anymore, right? It's a program running on a computer, it's consuming memory, it's consuming clock cycles, it's observabaly doing something over time. So all programs do things over time. But most real world programs ??? actually have observable behaviors, that is not just the fact that they're running on a computer, but that they're doing things, they're interacting with the outside world, they're talking over sockets, they're putting stuff on the screen, they pulling things in and out of the database. In particular though, we use one critical measure about how to define states, which is if you ask the same question twice, and you get different answers, then there's state. I don't care where you put it, you put it in a process, you put it in an agent, you put it in an atom, you know, in a variable, doesn't matter, in a database. If you ask the same question twice and get different answers at different times, you got states. So again, the word time just came up again there.

So I think most programs are processes which means we need to talk about the part of your program that can't be purely functional, the part that's gonna have to produce different answers at different times. How do you do that, and not make a complete mess out of what you created with the shining pure part. In particular though I wanna highlight the fact that this talk is strictly about the notion of state and time in a local context, I'm talking about in the same process. There're a completely different set of requirements and characteristics of distributed programs, where you cannot do the same things that you can do in the same process. So I'm talking only about same process concurrency and state.
